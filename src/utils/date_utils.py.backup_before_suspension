"""
Date and time parsing utilities for TRA announcements
"""

import re
from datetime import datetime, timedelta
from typing import Optional
from zoneinfo import ZoneInfo
from loguru import logger


# Timezone for Taiwan
TAIPEI_TZ = ZoneInfo("Asia/Taipei")


def parse_tra_date(date_str: str) -> str:
    """
    Parse TRA date format (YYYY/MM/DD) to ISO 8601 format

    Args:
        date_str: Date string in format "YYYY/MM/DD"

    Returns:
        ISO 8601 date string (YYYY-MM-DD)

    Examples:
        >>> parse_tra_date("2025/10/21")
        '2025-10-21'
    """
    try:
        # Replace slashes with hyphens for ISO format
        return date_str.replace("/", "-")
    except Exception as e:
        logger.debug(f"Failed to parse TRA date '{date_str}': {e}")
        return date_str


def parse_resumption_time(text: str, publish_date: str) -> Optional[datetime]:
    """
    Parse resumption time from Chinese text using regex patterns

    Handles formats like:
    - "今日19:00"
    - "明日凌晨"
    - "明日首班車"
    - "8月13日12時前"
    - "預計於今日19:00恢復行駛"

    Args:
        text: HTML or text content containing time information
        publish_date: Announcement publish date in YYYY/MM/DD format (used as reference date)

    Returns:
        Timezone-aware datetime object (Asia/Taipei) or None if parsing fails

    Examples:
        >>> parse_resumption_time("預計於今日19:00恢復行駛", "2025/08/13")
        datetime(2025, 8, 13, 19, 0, tzinfo=ZoneInfo('Asia/Taipei'))
    """
    if not text:
        return None

    try:
        # Use publish_date as reference, NOT today's date
        ref_date_str = publish_date.replace("/", "-")
        ref_date = datetime.strptime(ref_date_str, "%Y-%m-%d").replace(tzinfo=TAIPEI_TZ)

        # Remove "發佈日期" section to avoid extracting publish time as resumption time
        text = re.sub(r'發[佈布]日期[：:][^。\n]*[。\n]?', '', text)

        # Remove "發生時間" section to avoid extracting incident time as resumption time
        # Only remove until sentence end (。) or newline to avoid over-removal
        text = re.sub(r'發生時間[：:][^。\n]*[。\n]?', '', text)

        # Pattern 1: 今日 HH:MM or 今日HH:MM
        # IMPORTANT: Exclude announcement publication times ("發布新聞稿") and other non-resumption contexts
        pattern1 = r'今日\s*(\d{1,2})[：:時](\d{2})?'
        match = re.search(pattern1, text)
        if match:
            # Check context after the match for exclusion patterns (within 20 chars)
            context_after = text[match.end():min(len(text), match.end()+20)]
            exclusion_keywords = ['發布', '發車', '開車', '到站', '成立', '應變']

            if any(kw in context_after for kw in exclusion_keywords):
                logger.debug(f"Skipping Pattern 1 (今日HH:MM) due to exclusion keyword in context: {context_after[:20]}")
                # This is not a resumption time - skip to next pattern
            else:
                hour = int(match.group(1))
                minute = int(match.group(2)) if match.group(2) else 0
                return ref_date.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # Pattern 2: 明日 HH:MM or 明日HH:MM or 明(X)日HH:MM
        # For "明(X)日", use X as the day (NOT ref_date + 1)
        # IMPORTANT: Skip if this is "X時前停駛" pattern (handled by Pattern 2.7)
        pattern2 = r'明(?:\((\d+)\))?日\s*(\d{1,2})[：:時](\d{2})?'
        match = re.search(pattern2, text)
        if match:
            # Check if this is a non-resumption context
            # Look ahead after the match (15 chars) for exclusion patterns
            check_pos = match.end()
            remaining = text[check_pos:check_pos+15]

            # Exclusion patterns:
            # - "前停駛/不通" → Pattern 2.7
            # - "前之/前的" → describing information, not resumption
            # - "資訊/發布" → announcement info, not resumption
            exclusions = ['前停駛', '前不通', '前之', '前的', '資訊', '發布']

            if any(excl in remaining for excl in exclusions):
                # This is not "明日X時恢復" - skip this match
                logger.debug(f"Skipping Pattern 2 due to exclusion in context: {remaining[:15]}")
                pass
            else:
                paren_day = match.group(1)  # Day in parentheses (if exists)
                hour = int(match.group(2))
                minute = int(match.group(3)) if match.group(3) else 0

                if paren_day:
                    # "明(X)日" format - use X as the day
                    day = int(paren_day)
                    try:
                        result = ref_date.replace(day=day, hour=hour, minute=minute, second=0, microsecond=0)
                        return result
                    except ValueError:
                        pass  # Invalid date, fall through to default tomorrow

                # Regular "明日" - add 1 day
                tomorrow = ref_date + timedelta(days=1)
                return tomorrow.replace(hour=hour, minute=minute, second=0, microsecond=0)

        # Pattern 2.5: 明日首班車 or 今日首班車 or M月D日首班車 (first train, assume 5:30 AM)
        # For "明(X)日首班車", use X as the day (NOT ref_date + 1)
        tomorrow_first_train = re.search(r'明(?:\((\d+)\))?日.{0,10}?首班車', text)
        if tomorrow_first_train:
            paren_day = tomorrow_first_train.group(1)
            if paren_day:
                # "明(X)日首班車" - use X as the day
                day = int(paren_day)
                try:
                    result = ref_date.replace(day=day, hour=5, minute=30, second=0, microsecond=0)
                    return result
                except ValueError:
                    pass  # Invalid date, fall through
            # Regular "明日首班車" - add 1 day
            tomorrow = ref_date + timedelta(days=1)
            return tomorrow.replace(hour=5, minute=30, second=0, microsecond=0)

        if re.search(r'今日.{0,10}?首班車', text):
            return ref_date.replace(hour=5, minute=30, second=0, microsecond=0)

        # M月D日首班車 - extract specific date for first train
        # Allow weekday markers like "(一)", "(二)" between "日" and "首班車"
        first_train_pattern = r'(\d{1,2})月(\d{1,2})日(?:\([一二三四五六日]\))?.{0,10}?首班車'
        match = re.search(first_train_pattern, text)
        if match:
            month = int(match.group(1))
            day = int(match.group(2))
            year = ref_date.year
            try:
                result = datetime(year, month, day, 5, 30, tzinfo=TAIPEI_TZ)
                if result >= ref_date:  # Only if date is today or future
                    return result
            except ValueError:
                pass

        # Pattern 2.6: 明日末班車 or 今日末班車 (last train, assume 11:30 PM)
        # For "明(X)日末班車", use X as the day (NOT ref_date + 1)
        tomorrow_last_train = re.search(r'明(?:\((\d+)\))?日.{0,10}?末班車', text)
        if tomorrow_last_train:
            paren_day = tomorrow_last_train.group(1)
            if paren_day:
                # "明(X)日末班車" - use X as the day
                day = int(paren_day)
                try:
                    result = ref_date.replace(day=day, hour=23, minute=30, second=0, microsecond=0)
                    return result
                except ValueError:
                    pass  # Invalid date, fall through
            # Regular "明日末班車" - add 1 day
            tomorrow = ref_date + timedelta(days=1)
            return tomorrow.replace(hour=23, minute=30, second=0, microsecond=0)

        if re.search(r'今日.{0,10}?末班車', text):
            return ref_date.replace(hour=23, minute=30, second=0, microsecond=0)

        # Pattern 2.7: "X時前停駛" means "X時恢復"
        # "今日18時前停駛" → "今日18時恢復"
        # "明日10點前停駛" → "明日10點恢復"
        # "16日12時前停駛" → "16日12時恢復"
        # "明(23)日12時前停駛" → "23日12時恢復" (use date in parentheses, NOT +1 day)
        # IMPORTANT: Ensure no "後" between "前" and "停駛" (avoid "12時前...12時後停駛")
        # IMPORTANT: Do NOT extract if followed by uncertainty keywords
        stop_before_pattern = r'(\d{1,2})[時點]前([^後]{0,50}?)(?:停駛|不通)'
        match = re.search(stop_before_pattern, text)
        if match:
            # Check the text between "前" and "停駛/不通" for exception/qualification keywords
            # e.g., "12時前，除下列跨線列車指定行駛區間外，各級列車全區間停駛"
            between_text = match.group(2) if match.group(2) else ''
            exception_keywords = ['除', '僅', '指定', '部分', '特定', '跨線']

            if any(kw in between_text for kw in exception_keywords):
                logger.debug(f"Skipping Pattern 2.7 due to exception/qualification in: {between_text[:30]}")
                # This is not a simple "X時前停駛 → X時恢復" pattern with exceptions
            else:
                # Check for uncertainty indicators nearby (within 100 chars after match)
                context_after = text[match.end():min(len(text), match.end()+100)]
                uncertainty_keywords = ['陸續', '俟', '待.*?確認', '視.*?而定', '機動', '暫定']
                has_uncertainty = any(re.search(pattern, context_after) for pattern in uncertainty_keywords)

                if has_uncertainty:
                    logger.debug(f"Skipping Pattern 2.7 (X時前停駛) due to uncertainty in context: {context_after[:50]}...")
                    # Don't interpret "X時前停駛" as resumption time - skip to next pattern
                else:
                    hour = int(match.group(1))
                    # Check wider context (100 chars before match for date indicators)
                    context = text[max(0, match.start()-100):match.start()]

                    # Priority 1: "明(X)日" format - use X as the day (NOT ref_date + 1)
                    paren_date = re.search(r'明\((\d{1,2})\)日', context)
                    if paren_date:
                        day = int(paren_date.group(1))
                        try:
                            result = ref_date.replace(day=day, hour=hour, minute=0, second=0, microsecond=0)
                            return result
                        except ValueError:
                            pass  # Invalid date, fall through

                    # Priority 2: Explicit "X日" (e.g., "16日12時前") - use X as the day
                    # Must NOT be part of "今日" or "明日"
                    explicit_day = re.search(r'(?<!今)(?<!明)(\d{1,2})日', context)
                    if explicit_day:
                        day = int(explicit_day.group(1))
                        try:
                            result = ref_date.replace(day=day, hour=hour, minute=0, second=0, microsecond=0)
                            if result >= ref_date:  # Only if date is today or future
                                return result
                        except ValueError:
                            pass  # Invalid date, fall through

                    # Priority 3: "明日" (without parentheses) - add 1 day
                    if re.search(r'明日', context) and not paren_date:
                        tomorrow = ref_date + timedelta(days=1)
                        return tomorrow.replace(hour=hour, minute=0, second=0, microsecond=0)

                    # Priority 4: Default to today
                    return ref_date.replace(hour=hour, minute=0, second=0, microsecond=0)

        # Pattern 3: M月D日 HH時 with context (must have keywords nearby)
        # Only extract if date appears near resumption keywords
        # Allow time descriptors like "凌晨", "上午", "下午" between "日" and "時"
        # IMPORTANT: Exclude incident times (發生, 地震, 淹水) that are NOT resumption times
        resumption_keywords_p3 = ['預計', '恢復', '復駛', '通車', '修復完成', '營運']
        for keyword in resumption_keywords_p3:
            # Look for date within 30 characters after resumption keyword
            # Allow descriptors like "凌晨", "上午", "下午", "首班車" between "日" and time
            pattern3 = rf'{keyword}.{{0,30}}?(\d{{1,2}})月(\d{{1,2}})日(?:[凌上下午首末班車\s]{{0,10}})?(\d{{1,2}})[時:](\d{{2}})?'
            match = re.search(pattern3, text)
            if match:
                # Check context after the time match (within 20 chars) for exclusion keywords
                context_after = text[match.end():min(len(text), match.end()+20)]
                exclusion_keywords = ['發生', '地震', '影響', '淹水', '坍方', '中斷']

                if any(kw in context_after for kw in exclusion_keywords):
                    logger.debug(f"Skipping Pattern 3 (M月D日HH時) due to exclusion keyword in context: {context_after[:20]}")
                    continue

                month = int(match.group(1))
                day = int(match.group(2))
                hour = int(match.group(3))
                minute = int(match.group(4)) if match.group(4) else 0
                # Use reference year from publish_date
                year = ref_date.year
                try:
                    result = datetime(year, month, day, hour, minute, tzinfo=TAIPEI_TZ)
                    # If date is before publish_date, it's likely historical info - don't extract
                    if result < ref_date:
                        logger.debug(f"Date {result} is before publish_date {ref_date}, skipping")
                        continue
                    return result
                except ValueError:
                    logger.debug(f"Invalid date: {year}/{month}/{day} {hour}:{minute}")
                    continue

        # Pattern 4: 今日恢復 (without specific time) - must have resumption keywords
        # IMPORTANT: Exclude uncertain resumptions (陸續, 俟, 待, 視...而定)
        if '今日' in text and not re.search(pattern1, text):
            # Check for uncertainty indicators
            uncertainty_keywords = ['陸續', '俟', '待.*?確認', '視.*?而定', '機動', '暫定']
            has_uncertainty = any(re.search(pattern, text) for pattern in uncertainty_keywords)

            if not has_uncertainty:
                # Only use fallback if there are clear resumption indicators
                if any(kw in text for kw in ['恢復通車', '恢復行駛', '恢復營運']):
                    return ref_date.replace(hour=23, minute=59, second=59, microsecond=0)

        # Pattern 5: 明日恢復 (without specific time) - must have resumption keywords
        # IMPORTANT: Exclude uncertain resumptions
        if re.search(r'明(?:\(\d+\))?日', text) and not re.search(pattern2, text):
            # Check if it's about first/last train (already handled above)
            if not re.search(r'(?:首|末)班車', text):
                # Check for uncertainty indicators
                uncertainty_keywords = ['陸續', '俟', '待.*?確認', '視.*?而定', '機動', '暫定']
                has_uncertainty = any(re.search(pattern, text) for pattern in uncertainty_keywords)

                if not has_uncertainty:
                    # Only use fallback if there are clear resumption indicators
                    if any(kw in text for kw in ['恢復通車', '恢復行駛', '恢復營運']):
                        tomorrow = ref_date + timedelta(days=1)
                        return tomorrow.replace(hour=23, minute=59, second=59, microsecond=0)

        # Pattern 6: 凌晨 (early morning, assume 5:00 AM)
        if '凌晨' in text:
            if '明日' in text or '明天' in text:
                tomorrow = ref_date + timedelta(days=1)
                return tomorrow.replace(hour=5, minute=0, second=0, microsecond=0)
            else:
                return ref_date.replace(hour=5, minute=0, second=0, microsecond=0)

        # Pattern 7: Time with context (must have keywords like "預計", "恢復", "復駛" nearby)
        # Only extract if time appears in resumption context
        # IMPORTANT: Exclude train schedule, incident time, suspension time, etc.
        # IMPORTANT: Simple keywords FIRST to avoid greedy compound matching
        resumption_keywords = [
            '預計', '搶通', '修復完成', '恢復', '復駛', '通車', '營運',  # Simple keywords (priority)
            '預計.{0,20}?恢復', '預計.{0,20}?復駛', '預計.{0,20}?通車', '預計.{0,20}?搶通',  # Compound (limited length)
        ]
        for keyword in resumption_keywords:
            # Look for time within 10 characters after resumption keyword (stricter than before)
            pattern = rf'{keyword}.{{0,10}}?(\d{{1,2}})[：:時](\d{{2}})'
            match = re.search(pattern, text)
            if match:
                hour = int(match.group(1))
                minute = int(match.group(2))

                # Get context around the match (50 chars before and after for better exclusion checking)
                context_start = max(0, match.start()-50)
                context_end = min(len(text), match.end()+50)
                context = text[context_start:context_end]

                # Exclusion checks
                # IMPORTANT: Exclude repair/test completion times that are NOT resumption times
                exclusion_patterns = [
                    r'次\s*[\(（].*?[=開]',  # Train schedule: "306次(花蓮06:24="
                    r'[成發]立',  # Establishment: "成立應變小組"
                    r'應變',  # Emergency response: "應變小組"
                    r'接駁',  # Shuttle: "接駁車"
                    r'發車',  # Departure: "發車時刻"
                    r'開車',  # Departure: "開車時刻"
                    r'發布',  # Announcement time: "14時發布新聞稿"
                    r'到.{0,5}站',  # Arrival: "22:31到新左營站"
                    r'開.{0,5}站',  # Departure: "8:00開台北站"
                    r'完成試車',  # Test run completion: "16:00前完成試車"
                    r'試運轉',  # Test operation: "16:00試運轉"
                    r'於\d{1,2}:\d{2}修復',  # Repair completion: "預計於16:00修復"
                ]

                # Check if context contains exclusion patterns
                skip = False
                for excl_pattern in exclusion_patterns:
                    if re.search(excl_pattern, context):
                        logger.debug(f"Skipping time {hour}:{minute} due to exclusion pattern: {excl_pattern}")
                        skip = True
                        break

                if skip:
                    continue

                return ref_date.replace(hour=hour, minute=minute, second=0, microsecond=0)

        logger.debug(f"No resumption time pattern matched in text: {text[:100]}...")
        return None

    except Exception as e:
        logger.debug(f"Error parsing resumption time from '{text[:100]}...': {e}")
        return None
